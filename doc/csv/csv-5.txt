================================
クラスを定義する
================================

ここまでの章では、基本的なデータ構造である `tuple`, `list`, `dict` を使ってきました。
データを保持するだけの場合はこれらで十分ですが、データを使って何らかの処理を実現するには
「クラス」としてカプセル化しておくと便利なことが多々あります。
たとえば、１日の相場の動きを計算する処理もデータ構造とセットになっていると使いやすくなります。

Python の場合は `class` キーワードを使ってクラスを定義します。
クラスを実装するときは ``self`` というキーワードが欠かせません。
初めてクラスを実装するときは、いわゆるおまじないのようなものという理解でも構いませんが、
何度か実装を繰り返すとその必要性や意味について疑問が出てくる場合がほとんどでしょう。
詳しく知りたい場合はこちらのブログ記事を読んでみましょう。

* `Why explicit self has to stay`_

なお、 ``self`` を使う必要のないメソッドは、そもそもそのクラスに定義すべきメソッドではないかもしれません。
Python はトップレベルに関数を定義できますので、無理にクラスを定義する必要はないことを忘れないでください。
（Java の場合はすべての関数を何らかのクラスに実装する必要があります）

.. _Why explicit self has to stay: http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html


簡単な構文と定義
======================

*StockPrice* というクラスを定義してみます。
コンストラクタとして「データ日付,終値,始値,高値,安値」を受け付けます。
内部的に値を保持するときは小数に変換します。
１日の動き値は ``diff()`` というメソッドで呼び出せるようにします。

.. code-block:: python

    class StockPrice(object):

        def __init__(self, day, price_end, price_begin, price_max, price_min):
            self.day = day
            self.price_end = float(price_end)
            self.price_begin = float(price_begin)
            self.price_max = float(price_max)
            self.price_min = float(price_min)

        def diff(self):
            return self.price_end - self.price_begin

使うときは以下のように呼び出します。
引数の `tuple`, `list` にアスタリスクを付けると変数展開されますので、覚えておくと便利です。
`dict` の場合はアスタリスクを２つ付けると変数名と値に展開されます。

.. code-block:: python

    r = "2014-06-06,15077.24,15138.75,15144.34,15042.59".split(",")
    p1 = StockPrice(r[0], r[1], r[2], r[3], r[4])
    print(p1)
    p2 = StockPrice(*r)
    print(p2)


実装の改修
========================================

:file:`csv-2.py` を改修して :file:`csv-5.py` とします。

.. literalinclude:: /../src/csv-5.py
   :encoding: utf-8
   :language: python


パッケージング
========================================

スクリプトをたくさん書いていくと、似たような実装が様々な場所に散り散りになってしまいます。
全てをフラットに配置すると依存関係の把握が難しくなってしまいますので、パッケージとしてまとめます。
ここでは、引数処理の関数をパッケージとして共有しておきましょう。
プロジェクト内で共通となるデータ構造やクラス定義もまとめておくと良いでしょう。

適切にパッケージを作成することで次のようなメリットがあります。

* 関数やクラスを再利用できるようになる。
* 全体の見通しが立ちやすくなる。
* 部分的にテストできるようになる。

Python のパッケージは基本的にディレクトリ構造に一致します。
あるディレクトリを Python のパッケージとして有効にするためには、次のふたつの条件を満たす必要があります。

* パッケージのトップディレクトリが ``sys.path`` に含まれる。
* それぞれのディレクトリは :file:`__init__.py` を持つ。

:file:`__init__.py` は特別な意味を持つファイルで、パッケージに関するメタ情報などを記述します。
単なる Python ファイルですから、普通に Python スクリプトを記述しても構いません。
中身は空っぽでも構いませんが、コメントに概要くらいは書いておくと親切ですね。

たとえば、引数処理の関数を :file:`cmdline.py` ファイルに記述して *pyschool* パッケージに入れると、次の構造になります。

::

    pyschool
            __init__.py
            cmdline.py

スクリプトから使う場合は ``import`` を変更します。
``import`` は ``from`` と合わせて使うこともできます。
この記法を使うと、既存のコードをほとんど変更せずにモジュールを導入できます。

.. code-block:: python

    from pyschool.cmdline import parse_args

これまでに記述した :file:`csv-*.py` スクリプトは共通処理ばかりですので、試してみましょう。

.. note::

    インポートするモジュールのパス解決

    Python スクリプトは、それだけでモジュールとしてインポートできます。 インポートするディレクトリの指定方法はいくつかあります。

    * 標準ライブラリ置き場 (pyvenv/virtualenv 環境の *Lib* など)
    * カレントディレクトリ
    * 環境変数 `PYTHONPATH` で指定
    * Python スクリプト内で ``sys.path`` に追加

    実際には ``sys.path`` のリストが全てですが、その実現方法は色々ある、と覚えておいてください。

上記の :file:`csv-5.py` は以下のように変更できます。

.. literalinclude:: /../src/csv-5a.py
   :encoding: utf-8
   :language: python

次の章では、オブジェクト定義に O/R マッパーを使ってみましょう。
